const pascalCase = require('pascal-case')
const camelCase = require('camel-case')
const {
  icons,
  context,
  token,
  next,
  sectionCode,
  sectionName,
  addToken,
  keep,
  html,
  sectionStart,
  isHeading
} = require('./common')
const { fieldName } = require('./screens')
const { processLinks } = require('./refs')

const entityCode = () => sectionCode() ||
  pascalCase(sectionName().replace(/[^\w]+/g, ' '))

const entityStart = () => {
  const sectionCodeValue = sectionCode()
  const entityCodeValue = entityCode()
  sectionStart('entity', sectionCodeValue || entityCodeValue, token().text.substring('Entity:'.length))
  if (!sectionCodeValue) {
    token().text += ' `' + entityCodeValue + '`'
  }
  token().text = token().text.replace(/Entity:\s*/, `<i class="${icons.entity} text-muted"></i> `)
  keep()
}
const attributesStart = () => {
  keep()
  html(`<table class="table table-bordered table-hover">
<thead>
<tr>
<th>Name</th>
<th>Status</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>`)
  context().inAttributes = true
}
const attributesEnd = () => {
  html(`</tbody>
</table>`)
  context().inAttributes = false
}
const attributeStart = () => {
  html('<tr>')
  next()
  context().inAttribute = true
}
const attributeEnd = () => {
  html('</tr>')
  next()
  context().inAttribute = false
}
const attributeNameAndCode = () => {
  let name = fieldName()
  let code
  const re = /`([^`]*)`/
  if (!name.match(re)) {
    code = camelCase(name)
    name += `<code class="float-right">${code}</code>`
  }
  while (name.match(re)) {
    if (!code) {
      code = name.match(re)[1]
    }
    name = name.replace('`', '<code class="float-right">')
    name = name.replace('`', '</code>')
  }
  return { name, code }
}
const cardinality = statusCandidate => {
  if (!statusCandidate) {
    return null
  }
  const normalized = statusCandidate
    .toLowerCase()
    .replace(/[*m]/g, 'n')
  const matches = normalized.match(/(?:[01]..1|[01]..n|1|n):(?:[01]..1|[01]..n|1|n)/)
  const updated = statusCandidate.replace(/:/, ' : ')
  return matches ? updated : null
}
const attributeStatusAndDataType = () => {
  const statuses = {
    autoGeneratedPrimaryKey: { code: 'APK', label: 'Auto-generated primary key', variant: 'danger' },
    naturalPrimaryKey: { code: 'NPK', label: 'Natural primary key', variant: 'danger' },
    foreignPrimaryKey: { code: 'FPK', label: 'Foreign primary key', variant: 'danger' },
    primaryKey: { code: 'PK', label: 'Primary key', variant: 'danger' },
    foreignKey: { code: 'FK', label: 'Foreign key', variant: 'dark' },
    optionalForeignKey: { code: 'OFK', label: 'Optional foreign key', variant: 'dark' },
    naturalKey: { code: 'NK', label: 'Natural key', variant: 'warning' },
    businessKey: { code: 'BK', label: 'Business key', variant: 'warning' },
    unique: { code: 'U', label: 'Unique', variant: 'warning' },
    optionalUnique: { code: 'OU', label: 'Optional unique', variant: 'warning' },
    mandatory: { code: 'M', label: 'Mandatory', variant: 'primary' },
    conditional: { code: 'C', label: 'Conditional', variant: 'info' },
    optional: { code: 'O', label: 'Optional', variant: 'success' },
    readOnly: { code: 'RO', label: 'Read-only', variant: 'secondary' }
  }
  let text = token().text
  const descriptionStart = text.indexOf(' - ')
  const parenStart = text.indexOf('(')
  if (descriptionStart >= 0 && descriptionStart < parenStart) {
    text = text.substring(0, descriptionStart)
  }
  const matches = text.match(/\([\s]*([^\s()]+|[^()]*|[^()]*\([^()]*\)[^()]*)[\s]*\)/)
  const statusAndDataType = matches && matches[1].trim()
  const split = statusAndDataType && statusAndDataType.split(/\s/)
  const statusCandidate = split && split[0]
  const statusKey = Object.keys(statuses).includes(statusCandidate) ? statusCandidate
    : Object.values(statuses).map(({ code }) => code).includes(statusCandidate)
      ? Object.keys(statuses).find(key => statuses[key].code === statusCandidate)
      : null
  if (statusKey) {
    return [statuses[statusKey], split.splice(1).join(' ').trim()]
  }
  const card = cardinality(statusCandidate)
  if (card) {
    return [card, split.splice(1).join(' ').trim()]
  }
  return [null, statusAndDataType]
}
const attributeDescription = () => {
  const matches = token().text.match(/(?:\(.*\))? - (.*)/)
  return (matches && matches[1].trim()) || ''
}
const attributeDataType = dataType => {
  dataType = processLinks(dataType)
  html(`<td>`)
  addToken({ type: 'text', text: dataType })
  html(`</td>`)
}
const attribute = () => {
  const { name, code } = attributeNameAndCode()
  const statusAndDataType = attributeStatusAndDataType()
  const status = statusAndDataType[0]
  const dataType = statusAndDataType[1]
  const description = attributeDescription()
  html(`<td>${name}</td>`)
  if (status === null) {
    html('<td></td>')
  } else if (typeof status === 'string') {
    html(`<td>${status}</td>`)
  } else {
    html(`<td title="${status.label}"><span class="badge badge-${status.variant}">${status.code}</span></td>`)
  }
  if (dataType) {
    attributeDataType(dataType)
  } else {
    html('<td></td>')
  }
  if (description) {
    html(`<td>`)
    addToken({ type: 'text', text: processLinks(description) })
    html(`</td>`)
  } else {
    html('<td></td>')
  }
  next()
  context().meta.attributeToEntity[context().sectionCode + '.' + code] = context().sectionCode
}

const isEntity = () => isHeading(2) && token().text.startsWith('Entity:')
const isAttributes = () => isHeading(3) && token().text.startsWith('Attributes:')

module.exports = {
  entityStart,
  attributesStart,
  attributesEnd,
  attributeStart,
  attributeEnd,
  attribute,
  isEntity,
  isAttributes
}
