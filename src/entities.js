const pascalCase = require('pascal-case')
const camelCase = require('camel-case')
const {
  icons,
  context,
  token,
  next,
  sectionCode,
  sectionName,
  addToken,
  keep,
  html,
  sectionStart,
  isHeading,
  fieldName,
  fieldStatusAndType,
  fieldValue,
  fieldHint
} = require('./common')
const { processLinks } = require('./refs')

const entityCode = () => sectionCode() ||
  pascalCase(sectionName().replace(/[^\w]+/g, ' '))

const entityStart = () => {
  const sectionCodeValue = sectionCode()
  const entityCodeValue = entityCode()
  sectionStart('entity', sectionCodeValue || entityCodeValue, token().text.substring('Entity:'.length))
  if (!sectionCodeValue) {
    token().text += ' `' + entityCodeValue + '`'
  }
  token().text = token().text.replace(/Entity:\s*/, `<i class="${icons.entity} text-muted"></i> `)
  keep()
}
const attributesStart = () => {
  keep()
  html(`<table class="table table-bordered table-hover">
<thead>
<tr>
<th>Name</th>
<th>Status</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>`)
  context().inAttributes = true
}
const attributesEnd = () => {
  html(`</tbody>
</table>`)
  context().inAttributes = false
}
const attributeStart = () => {
  html('<tr>')
  next()
  context().inAttribute = true
}
const attributeEnd = () => {
  html('</tr>')
  next()
  context().inAttribute = false
}

const attributeNameAndCode = fName => {
  let name = fName
  let code
  const re = /`([^`]*)`/
  if (!name.match(re)) {
    code = camelCase(name)
    name += `<code class="float-right">${code}</code>`
  }
  while (name.match(re)) {
    if (!code) {
      code = name.match(re)[1]
    }
    name = name.replace('`', '<code class="float-right">')
    name = name.replace('`', '</code>')
  }
  return { name, code }
}
const cardinality = statusCandidate => {
  if (!statusCandidate) {
    return null
  }
  const normalized = statusCandidate
    .toLowerCase()
    .replace(/[*m]/g, 'n')
  const matches = normalized.match(/(?:[01]..1|[01]..n|1|n):(?:[01]..1|[01]..n|1|n)/)
  const updated = statusCandidate.replace(/:/, ' : ')
  return matches ? updated : null
}
const attributeStatusAndDataType = statusAndType => {
  const statuses = {
    autoGeneratedPrimaryKey: { code: 'APK', label: 'Auto-generated primary key', variant: 'danger' },
    naturalPrimaryKey: { code: 'NPK', label: 'Natural primary key', variant: 'danger' },
    foreignPrimaryKey: { code: 'FPK', label: 'Foreign primary key', variant: 'danger' },
    primaryKey: { code: 'PK', label: 'Primary key', variant: 'danger' },
    foreignKey: { code: 'FK', label: 'Foreign key', variant: 'dark' },
    optionalForeignKey: { code: 'OFK', label: 'Optional foreign key', variant: 'dark' },
    naturalKey: { code: 'NK', label: 'Natural key', variant: 'warning' },
    businessKey: { code: 'BK', label: 'Business key', variant: 'warning' },
    unique: { code: 'U', label: 'Unique', variant: 'warning' },
    optionalUnique: { code: 'OU', label: 'Optional unique', variant: 'warning' },
    mandatory: { code: 'M', label: 'Mandatory', variant: 'primary' },
    conditional: { code: 'C', label: 'Conditional', variant: 'info' },
    optional: { code: 'O', label: 'Optional', variant: 'success' },
    readOnly: { code: 'RO', label: 'Read-only', variant: 'secondary' }
  }
  const split = statusAndType.split(/\s/)
  const firstWord = split[0] || ''
  const rest = split.splice(1).join(' ').trim()
  const statusKey = Object.keys(statuses).includes(firstWord) ? firstWord
    : Object.values(statuses).map(({ code }) => code).includes(firstWord)
      ? Object.keys(statuses).find(key => statuses[key].code === firstWord)
      : null
  if (statusKey) {
    return [statuses[statusKey], rest]
  }
  const card = cardinality(firstWord)
  if (card) {
    return [card, rest]
  }
  return [null, statusAndType]
}
const parseAttribute = () => {
  let rest = token().text
  let fName, statusAndType, value, description
  [fName, rest] = fieldName(rest)
  const { name, code } = attributeNameAndCode(fName);
  [statusAndType, rest] = fieldStatusAndType(rest)
  const [status, dataType] = attributeStatusAndDataType(statusAndType);
  [value, rest] = fieldValue(rest)
  description = fieldHint(rest)
  return { name, code, status, dataType, value, description }
}
const attributeDataType = dataType => {
  dataType = processLinks(dataType)
  html(`<td>`)
  addToken({ type: 'text', text: dataType })
  html(`</td>`)
}
const attribute = () => {
  const { name, code, status, dataType, description } = parseAttribute()
  html(`<td>${name}</td>`)
  if (status === null) {
    html('<td></td>')
  } else if (typeof status === 'string') {
    html(`<td>${status}</td>`)
  } else {
    html(`<td title="${status.label}"><span class="badge badge-${status.variant}">${status.code}</span></td>`)
  }
  if (dataType) {
    attributeDataType(dataType)
  } else {
    html('<td></td>')
  }
  if (description) {
    html(`<td>`)
    addToken({ type: 'text', text: processLinks(description) })
    html(`</td>`)
  } else {
    html('<td></td>')
  }
  next()
  context().meta.attributeToEntity[context().sectionCode + '.' + code] = context().sectionCode
}

const isEntity = () => isHeading(2) && token().text.startsWith('Entity:')
const isAttributes = () => isHeading(3) && token().text.startsWith('Attributes:')

module.exports = {
  entityStart,
  attributesStart,
  attributesEnd,
  attributeStart,
  attributeEnd,
  attribute,
  isEntity,
  isAttributes
}
